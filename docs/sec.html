<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <meta name="theme-color" content="#06070a" />
  <title>Tap-n-Score™ — SEC</title>

  <style>
    :root{
      --bg0:#05060a;
      --bg1:#0a0c12;

      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.045);
      --stroke: rgba(255,255,255,.12);
      --text:#eef2f7;
      --muted: rgba(238,242,247,.65);
      --muted2: rgba(238,242,247,.45);
      --shadow: 0 20px 60px rgba(0,0,0,.55);
      --radius: 22px;

      --red:#d64040;
      --white:#eef2f7;
      --blue:#2f66ff;
      --green:#67f3a4;

      --btn: rgba(255,255,255,.07);
      --btnHover: rgba(255,255,255,.10);
      --btnStroke: rgba(255,255,255,.14);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(46,102,255,.10), transparent 60%),
        radial-gradient(1200px 800px at 80% 20%, rgba(214,64,64,.10), transparent 60%),
        radial-gradient(1200px 800px at 50% 90%, rgba(103,243,164,.06), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      padding: 14px 12px 22px;
    }

    .wrap{ max-width: 1080px; margin:0 auto; }
    .shell{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .top{
      padding: 14px 16px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.035), rgba(255,255,255,.02));
    }

    .title{
      margin:0;
      letter-spacing:.08em;
      font-weight: 900;
      font-size: clamp(22px, 3.7vw, 40px);
      text-transform: uppercase;
      line-height:1.05;
    }
    .title .r{ color: var(--red); }
    .title .w{ color: var(--white); }
    .title .b{ color: var(--blue); }

    .sub{
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content: space-between;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
      font-size: 12px;
      letter-spacing:.06em;
      text-transform: uppercase;
      font-weight: 850;
    }
    .dotOk{
      width:10px;height:10px;border-radius:50%;
      background: var(--green);
      box-shadow: 0 0 0 3px rgba(103,243,164,.10);
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 14px;
    }
    @media (min-width: 980px){
      .grid{ grid-template-columns: 1.25fr .75fr; }
    }

    .card{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 18px;
      padding: 12px;
    }

    .cardTitle{
      margin:0 0 10px;
      font-size: 12px;
      letter-spacing:.14em;
      text-transform: uppercase;
      color: var(--muted);
      font-weight: 900;
    }

    /* --- Action bar (smaller buttons) */
    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .btn{
      appearance:none;
      border: 1px solid var(--btnStroke);
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 850;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:hover{ background: var(--btnHover); }
    .btn:active{ transform: translateY(1px); }
    .btnPrimary{
      border-color: rgba(103,243,164,.35);
      background: rgba(103,243,164,.10);
    }
    .btnPrimary:hover{ background: rgba(103,243,164,.14); }
    .btnDisabled{ opacity:.45; pointer-events:none; }

    /* --- Target image / tap layer */
    .imgWrap{
      position: relative;
      border-radius: 16px;
      overflow:hidden;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.10);
      min-height: 260px;
    }
    img#targetImg{
      width:100%;
      height:auto;
      display:block;
      user-select:none;
      -webkit-user-drag:none;
    }
    .layer{
      position:absolute;
      inset:0;
      pointer-events:none;
    }
    .dot{
      position:absolute;
      width: 16px; height: 16px;
      border-radius: 50%;
      transform: translate(-50%,-50%);
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      border: 2px solid rgba(255,255,255,.85);
      opacity: .95;
    }
    .dotBull{ background: rgba(47,102,255,.95); }
    .dotShot{ background: rgba(214,64,64,.95); }

    .tapHint{
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    /* --- Results layout: compact hierarchy */
    .scorePanel{
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 12px;
      margin-top: 10px;
    }

    .scoreBar{
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      position:relative;
    }
    .scoreFill{
      height:100%;
      width: 0%;
      background: rgba(103,243,164,.85);
      transition: width .3s ease;
    }
    .scoreLine{
      margin-top: 8px;
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
    }
    .scoreLabel{
      color: var(--muted);
      font-size: 12px;
      letter-spacing:.12em;
      text-transform: uppercase;
      font-weight: 900;
    }
    .scoreValue{
      font-size: 16px;
      font-weight: 900;
      letter-spacing:.02em;
    }

    .pair{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }

    .miniCard{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 12px;
      min-height: 96px;
      display:flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .miniTop{
      display:flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .miniName{
      font-size: 12px;
      letter-spacing:.14em;
      text-transform: uppercase;
      color: var(--muted);
      font-weight: 950;
    }

    /* This is the “combined” box behavior: result + shots inside Elevation */
    .miniStatRow{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
      letter-spacing:.08em;
      text-transform: uppercase;
      font-weight: 850;
    }

    .bigDir{
      font-size: 28px;
      font-weight: 950;
      letter-spacing:.04em;
      line-height: 1.0;
      margin-top: 6px;
    }
    .bigNum{
      font-size: 22px;
      font-weight: 950;
      letter-spacing:.02em;
      margin-top: 2px;
    }
    .unit{
      color: var(--muted);
      font-size: 12px;
      font-weight: 900;
      letter-spacing:.10em;
      text-transform: uppercase;
      margin-left: 6px;
    }

    details{
      margin-top: 12px;
      background: var(--card2);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 10px 12px;
    }
    summary{
      cursor:pointer;
      font-weight: 900;
      color: var(--muted);
      letter-spacing: .06em;
      text-transform: uppercase;
      font-size: 12px;
      outline:none;
    }
    pre{
      margin: 10px 0 0;
      white-space: pre-wrap;
      word-break: break-word;
      color: rgba(238,242,247,.82);
      font-size: 12px;
      line-height: 1.35;
    }

    .foot{
      padding: 10px 16px 14px;
      color: rgba(238,242,247,.30);
      text-align:center;
      letter-spacing: .22em;
      font-weight: 950;
      text-transform: uppercase;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="shell">
      <div class="top">
        <h1 class="title">
          <span class="r">Shooter</span> <span class="w">Experience</span> <span class="b">Card</span>
        </h1>

        <div class="sub">
          <div class="pill" id="readyPill">
            <span class="dotOk"></span>
            <span id="readyText">Setup loaded</span>
          </div>

          <div class="pill" id="tapModePill">
            Tap: <span id="modeText">Bull</span>
          </div>
        </div>
      </div>

      <div class="grid">
        <!-- LEFT: IMAGE + TAPS + SCORE -->
        <div class="card">
          <div class="actions">
            <input id="photoInput" type="file" accept="image/*" style="display:none;" />
            <button id="chooseBtn" class="btn">Choose Photo</button>
            <button id="clearBtn" class="btn">Clear</button>
            <button id="resultsBtn" class="btn btnPrimary btnDisabled">Show Results</button>
            <a id="backSetup" class="btn" href="./target.html" style="text-decoration:none;display:inline-flex;align-items:center;">Setup</a>
          </div>

          <div class="tapHint" id="instruction">
            Tap the <b>bull</b> first (blue). Then tap shots (red).<br/>
            (Distance/MOA are locked upstream and not shown here.)
          </div>

          <div class="imgWrap" id="imgWrap">
            <img id="targetImg" alt="Target image" />
            <div class="layer" id="dotsLayer"></div>
          </div>

          <div class="scorePanel">
            <div class="scoreLabel">Shooter’s score</div>
            <div class="scoreBar" aria-label="score bar">
              <div class="scoreFill" id="scoreFill"></div>
            </div>
            <div class="scoreLine">
              <div class="scoreValue" id="scoreValue">—</div>
              <div class="scoreLabel" id="shotsInline">Shots: 0</div>
            </div>

            <div class="pair">
              <!-- ELEVATION BOX (combined with shots + tighter) -->
              <div class="miniCard">
                <div class="miniTop">
                  <div class="miniName">Elevation</div>
                </div>
                <div>
                  <div class="bigDir" id="elevDir">—</div>
                  <div class="bigNum"><span id="elevClicks">0.00</span><span class="unit">clicks</span></div>
                  <div class="miniStatRow">
                    <span>Shots</span>
                    <span id="shotsSmall">0</span>
                  </div>
                </div>
              </div>

              <!-- WINDAGE BOX -->
              <div class="miniCard">
                <div class="miniTop">
                  <div class="miniName">Windage</div>
                </div>
                <div>
                  <div class="bigDir" id="windDir">—</div>
                  <div class="bigNum"><span id="windClicks">0.00</span><span class="unit">clicks</span></div>
                  <div class="miniStatRow">
                    <span>Status</span>
                    <span id="windStatus">Ready</span>
                  </div>
                </div>
              </div>
            </div>

            <details>
              <summary>Diagnostics</summary>
              <pre id="diagOut">(none)</pre>
            </details>
          </div>
        </div>

        <!-- RIGHT: CTA (kept minimal) -->
        <div class="card">
          <div class="cardTitle">Next</div>
          <button id="downloadGo" class="btn btnPrimary btnDisabled">Download SEC</button>
          <div class="tapHint" id="downloadHint">Run results first to generate a downloadable SEC.</div>

          <div style="height:10px;"></div>
          <button class="btn" onclick="window.location.href='./target.html'">Back to Setup</button>
          <div class="tapHint" style="margin-top:10px;color:var(--muted2);">
            Tip: If your taps feel off, pinch-zoom to focus before tapping.
          </div>
        </div>
      </div>

      <div class="foot">SCZN3</div>
    </div>
  </div>

  <script>
    (() => {
      const $ = (id) => document.getElementById(id);

      // Elements
      const chooseBtn = $("chooseBtn");
      const clearBtn = $("clearBtn");
      const resultsBtn = $("resultsBtn");
      const downloadGo = $("downloadGo");

      const photoInput = $("photoInput");
      const imgWrap = $("imgWrap");
      const targetImg = $("targetImg");
      const dotsLayer = $("dotsLayer");

      const instruction = $("instruction");
      const readyText = $("readyText");
      const modeText = $("modeText");

      const scoreFill = $("scoreFill");
      const scoreValue = $("scoreValue");

      const elevDir = $("elevDir");
      const elevClicks = $("elevClicks");
      const windDir = $("windDir");
      const windClicks = $("windClicks");
      const windStatus = $("windStatus");

      const shotsInline = $("shotsInline");
      const shotsSmall = $("shotsSmall");

      const downloadHint = $("downloadHint");
      const diagOut = $("diagOut");

      // State
      let selectedFile = null;
      let objectUrl = null;

      // Tap state stored in image-relative percentages (0..1)
      let bull = null;        // {x,y} in 0..1
      let shots = [];         // [{x,y}...]
      let lastSecDataUrl = ""; // data:image/png;base64,...

      // Settings (MUST come from target page)
      const params = new URLSearchParams(window.location.search);
      const distance = Number(params.get("distance") || localStorage.getItem("sczn3_distanceYds") || "");
      const moa = Number(params.get("moa") || localStorage.getItem("sczn3_moaPerClick") || "");

      // Hard stop: if missing, force setup page
      if (!Number.isFinite(distance) || distance <= 0 || !Number.isFinite(moa) || moa <= 0) {
        window.location.href = "./target.html";
        return;
      }

      // Persist again (in case user shared direct link)
      localStorage.setItem("sczn3_distanceYds", String(distance));
      localStorage.setItem("sczn3_moaPerClick", String(moa));

      readyText.textContent = "Setup locked";

      // API base: try vendor.json (optional), else same origin relative calls will fail on GH pages
      let API_BASE = ""; // set by vendor.json if present

      async function loadVendor() {
        try {
          const res = await fetch("./vendor.json", { cache: "no-store" });
          if (!res.ok) throw new Error("vendor.json not found");
          const v = await res.json();
          if (v && typeof v.apiBase === "string") API_BASE = v.apiBase.replace(/\/+$/,"");
        } catch (e) {
          // ok, run without vendor config (fallback results still render)
        }
      }

      function setDiag(obj) {
        diagOut.textContent = JSON.stringify(obj, null, 2);
      }

      function clamp01(n){ return Math.max(0, Math.min(1, n)); }

      function resetAll() {
        bull = null;
        shots = [];
        lastSecDataUrl = "";

        dotsLayer.innerHTML = "";
        resultsBtn.classList.add("btnDisabled");
        downloadGo.classList.add("btnDisabled");

        scoreFill.style.width = "0%";
        scoreValue.textContent = "—";
        elevDir.textContent = "—";
        elevClicks.textContent = "0.00";
        windDir.textContent = "—";
        windClicks.textContent = "0.00";
        windStatus.textContent = "Ready";

        shotsInline.textContent = "Shots: 0";
        shotsSmall.textContent = "0";

        modeText.textContent = "Bull";
        instruction.innerHTML = "Tap the <b>bull</b> first (blue). Then tap shots (red).<br/>(Distance/MOA are locked upstream and not shown here.)";
        downloadHint.textContent = "Run results first to generate a downloadable SEC.";

        setDiag({ ok:true, cleared:true });
      }

      function addDot(x01, y01, kind) {
        const d = document.createElement("div");
        d.className = "dot " + (kind === "bull" ? "dotBull" : "dotShot");
        d.style.left = (x01 * 100) + "%";
        d.style.top  = (y01 * 100) + "%";
        dotsLayer.appendChild(d);
      }

      function rebuildDots() {
        dotsLayer.innerHTML = "";
        if (bull) addDot(bull.x, bull.y, "bull");
        for (const s of shots) addDot(s.x, s.y, "shot");
      }

      // Convert pointer event -> normalized 0..1 within displayed image
      function getTap01(evt) {
        const rect = targetImg.getBoundingClientRect();
        const x = clamp01((evt.clientX - rect.left) / rect.width);
        const y = clamp01((evt.clientY - rect.top) / rect.height);
        return { x, y };
      }

      function updateTapModeUI() {
        if (!bull) {
          modeText.textContent = "Bull";
          instruction.innerHTML = "Tap the <b>bull</b> first (blue). Then tap shots (red).";
        } else {
          modeText.textContent = "Shots";
          instruction.innerHTML = "Now tap <b>shots</b> (red). Add 3–5 hits, then tap <b>Show Results</b>.";
        }
      }

      function updateShotCounts() {
        shotsInline.textContent = "Shots: " + shots.length;
        shotsSmall.textContent = String(shots.length);

        if (bull && shots.length > 0) {
          resultsBtn.classList.remove("btnDisabled");
        } else {
          resultsBtn.classList.add("btnDisabled");
        }
      }

      // Fallback direction logic (signed deltas)
      // delta = bull - poib
      // Screen coords: x right positive, y down positive.
      function fallbackDirections(deltaX, deltaY) {
        const wind = deltaX > 0 ? "RIGHT" : (deltaX < 0 ? "LEFT" : "CENTER");
        const elev = deltaY > 0 ? "DOWN" : (deltaY < 0 ? "UP" : "CENTER");
        return { wind, elev };
      }

      function format2(n) {
        return (Math.round(n * 100) / 100).toFixed(2);
      }

      function computePOIB(shotsArr) {
        const n = shotsArr.length || 1;
        let sx = 0, sy = 0;
        for (const p of shotsArr) { sx += p.x; sy += p.y; }
        return { x: sx / n, y: sy / n };
      }

      // Create a simple SEC PNG in-browser (no POIB label, no red/white/blue line)
      async function makeSecPngDataUrl(result) {
        const W = 1200, H = 700;
        const canvas = document.createElement("canvas");
        canvas.width = W; canvas.height = H;
        const ctx = canvas.getContext("2d");

        // Background
        ctx.fillStyle = "#0a0c12";
        ctx.fillRect(0,0,W,H);

        // Soft panel
        ctx.fillStyle = "rgba(255,255,255,0.06)";
        roundRect(ctx, 30, 30, W-60, H-60, 26);
        ctx.fill();

        // Title (red/white/blue WORDS ONLY; no stripe)
        ctx.font = "900 46px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.textBaseline = "top";
        ctx.letterSpacing = "2px";

        // Safari doesn't support letterSpacing; ignore safely
        const t1 = "SHOOTER";
        const t2 = " EXPERIENCE ";
        const t3 = "CARD";

        let x = 60, y = 52;
        ctx.fillStyle = "#d64040"; ctx.fillText(t1, x, y);
        x += ctx.measureText(t1).width;
        ctx.fillStyle = "#eef2f7"; ctx.fillText(t2, x, y);
        x += ctx.measureText(t2).width;
        ctx.fillStyle = "#2f66ff"; ctx.fillText(t3, x, y);

        // Score label
        ctx.fillStyle = "rgba(238,242,247,0.70)";
        ctx.font = "800 18px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText("SHOOTER’S SCORE", 60, 125);

        // Score bar
        const barX = 60, barY = 160, barW = W-120, barH = 18;
        ctx.fillStyle = "rgba(255,255,255,0.10)";
        roundRect(ctx, barX, barY, barW, barH, 999); ctx.fill();

        const pct = Math.max(0, Math.min(1, (result.scorePercent || 0)));
        ctx.fillStyle = "rgba(103,243,164,0.90)";
        roundRect(ctx, barX, barY, Math.max(10, barW * pct), barH, 999); ctx.fill();

        // Two stat boxes (Elevation includes shots)
        const boxY = 220, boxH = 190, gap = 20;
        const boxW = (W - 120 - gap) / 2;
        const leftX = 60, rightX = 60 + boxW + gap;

        ctx.fillStyle = "rgba(255,255,255,0.05)";
        roundRect(ctx, leftX, boxY, boxW, boxH, 18); ctx.fill();
        roundRect(ctx, rightX, boxY, boxW, boxH, 18); ctx.fill();

        // Labels
        ctx.fillStyle = "rgba(238,242,247,0.60)";
        ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText("ELEVATION", leftX+18, boxY+16);
        ctx.fillText("WINDAGE", rightX+18, boxY+16);

        // Directions
        ctx.fillStyle = "#67f3a4";
        ctx.font = "950 46px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText(result.elevDir || "—", leftX+18, boxY+52);
        ctx.fillText(result.windDir || "—", rightX+18, boxY+52);

        // Click numbers
        ctx.fillStyle = "#eef2f7";
        ctx.font = "950 44px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText(format2(result.elevClicks || 0), leftX+18, boxY+108);
        ctx.fillText(format2(result.windClicks || 0), rightX+18, boxY+108);

        ctx.fillStyle = "rgba(238,242,247,0.55)";
        ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText("CLICKS", leftX+18 + ctx.measureText(format2(result.elevClicks||0)).width + 10, boxY+122);
        ctx.fillText("CLICKS", rightX+18 + ctx.measureText(format2(result.windClicks||0)).width + 10, boxY+122);

        // Shots inside elevation box (combined)
        ctx.fillStyle = "rgba(238,242,247,0.65)";
        ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText("SHOTS", leftX+18, boxY+160);
        ctx.fillStyle = "#eef2f7";
        ctx.fillText(String(result.shots || 0), leftX+90, boxY+160);

        // Footer
        ctx.fillStyle = "rgba(238,242,247,0.25)";
        ctx.font = "900 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText("SCZN3", 60, H-48);

        return canvas.toDataURL("image/png");
      }

      function roundRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
      }

      // Core result path
      async function runResults() {
        if (!bull || shots.length === 0) return;

        const poib = computePOIB(shots);
        const dx = (bull.x - poib.x);
        const dy = (bull.y - poib.y);

        // inches are unknown without calibration, so we’ll treat dx/dy as “relative”
        // Backend (if configured) can map pixels->inches. We still compute click counts using inches only if backend returns inches.
        // Here: we compute clicks using normalized distance (still useful for UI checks), but backend should override.
        // We'll call backend first if API_BASE exists.

        let result = {
          ok: true,
          shots: shots.length,
          elevDir: "—",
          windDir: "—",
          elevClicks: 0,
          windClicks: 0,
          scorePercent: 0
        };

        // Simple score % (tight cluster better): inverse of dispersion
        // Use normalized values; backend can override later.
        const distNorm = Math.sqrt(dx*dx + dy*dy);
        const pct = Math.max(0, Math.min(1, 1 - (distNorm * 1.25)));
        result.scorePercent = pct;
        scoreFill.style.width = Math.round(pct * 100) + "%";
        scoreValue.textContent = Math.round(pct * 100) + "%";

        // Backend call (authoritative direction + clicks)
        const payload = {
          distanceYds: distance,
          moaPerClick: moa,
          bull: bull,
          shots: shots
        };

        let backend = null;
        if (API_BASE) {
          try {
            const res = await fetch(API_BASE + "/api/calc", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            if (res.ok) backend = await res.json();
          } catch (e) {
            backend = null;
          }
        }

        if (backend && backend.ok) {
          // Expect backend fields (best effort)
          // directions: backend.elevationDirection, backend.windageDirection
          // clicks: backend.elevationClicks, backend.windageClicks
          result.elevDir = (backend.elevationDirection || backend.elevDir || "—").toUpperCase();
          result.windDir = (backend.windageDirection || backend.windDir || "—").toUpperCase();
          result.elevClicks = Number(backend.elevationClicks ?? backend.elevClicks ?? 0) || 0;
          result.windClicks = Number(backend.windageClicks ?? backend.windClicks ?? 0) || 0;

          // If backend returns a score percent, use it
          if (Number.isFinite(Number(backend.scorePercent))) {
            result.scorePercent = Math.max(0, Math.min(1, Number(backend.scorePercent)));
            scoreFill.style.width = Math.round(result.scorePercent * 100) + "%";
            scoreValue.textContent = Math.round(result.scorePercent * 100) + "%";
          }
        } else {
          // Fallback: directions from signed deltas, clicks from MOA math using a fake inch conversion.
          // Use 1.047" per MOA at 100 yards scaling; but we don't know inches here.
          // So we compute clicks in "relative units" to keep UI moving. Backend should be used for real clicks.
          const dirs = fallbackDirections(dx, dy);
          result.elevDir = dirs.elev;
          result.windDir = dirs.wind;

          // Relative clicks: convert normalized displacement into pseudo-inches by assuming image width = 10"
          const pseudoInchesX = dx * 10;
          const pseudoInchesY = dy * 10;

          const inchPerMoaAtDist = 1.047 * (distance / 100);
          const moaX = Math.abs(pseudoInchesX) / inchPerMoaAtDist;
          const moaY = Math.abs(pseudoInchesY) / inchPerMoaAtDist;

          result.windClicks = moaX / moa;
          result.elevClicks = moaY / moa;
        }

        // Render
        elevDir.textContent = result.elevDir;
        windDir.textContent = result.windDir;
        elevClicks.textContent = format2(result.elevClicks);
        windClicks.textContent = format2(result.windClicks);

        windStatus.textContent = "Done";
        shotsInline.textContent = "Shots: " + result.shots;
        shotsSmall.textContent = String(result.shots);

        // Generate SEC image (no POIB label, no stripe)
        lastSecDataUrl = await makeSecPngDataUrl(result);

        // Enable download routing
        downloadGo.classList.remove("btnDisabled");
        downloadHint.textContent = "Ready. Tap Download SEC.";

        setDiag({
          ok:true,
          settings: { distanceYds: distance, moaPerClick: moa },
          bull, shotsCount: shots.length,
          poib,
          delta: { x: dx, y: dy },
          usedBackend: Boolean(backend && backend.ok),
          backendPreview: backend ? Object.keys(backend) : null
        });
      }

      // Choose photo
      chooseBtn.addEventListener("click", () => photoInput.click());

      photoInput.addEventListener("change", () => {
        const f = photoInput.files && photoInput.files[0];
        if (!f) return;

        selectedFile = f;

        if (objectUrl) URL.revokeObjectURL(objectUrl);
        objectUrl = URL.createObjectURL(f);

        targetImg.src = objectUrl;

        // enable tapping
        targetImg.onload = () => {
          resetAll();
          // allow taps now
          imgWrap.style.cursor = "crosshair";
          setDiag({ ok:true, photoLoaded:true, name:f.name, size:f.size });
        };
      });

      // Tapping (use pointerdown on the image itself)
      targetImg.addEventListener("pointerdown", (evt) => {
        if (!targetImg.src) return;

        // prevent scroll-zoom weirdness
        evt.preventDefault();

        const p = getTap01(evt);

        if (!bull) {
          bull = p;
        } else {
          shots.push(p);
        }

        rebuildDots();
        updateTapModeUI();
        updateShotCounts();

        // Disable results until we have bull+shots
        if (bull && shots.length > 0) resultsBtn.classList.remove("btnDisabled");
      }, { passive:false });

      // Clear
      clearBtn.addEventListener("click", () => resetAll());

      // Show results
      resultsBtn.addEventListener("click", async () => {
        if (resultsBtn.classList.contains("btnDisabled")) return;
        resultsBtn.textContent = "Working…";
        try {
          await runResults();
        } finally {
          resultsBtn.textContent = "Show Results";
        }
      });

      // Download routing
      downloadGo.addEventListener("click", () => {
        if (downloadGo.classList.contains("btnDisabled")) return;

        // Route to download.html with data URL (works on GH pages)
        const fromPath = "./sec.html?distance=" + encodeURIComponent(String(distance)) + "&moa=" + encodeURIComponent(String(moa));
        const targetPath = "./target.html";

        const url = new URL("./download.html", window.location.href);
        url.searchParams.set("img", lastSecDataUrl);
        url.searchParams.set("from", fromPath);
        url.searchParams.set("target", targetPath);

        window.location.href = url.toString();
      });

      // Boot
      (async () => {
        await loadVendor();
        resetAll();
        updateTapModeUI();
        updateShotCounts();

        setDiag({
          ok:true,
          note:"SEC loaded",
          settings: { distanceYds: distance, moaPerClick: moa },
          vendorApiBase: API_BASE || "(none)"
        });
      })();
    })();
  </script>
</body>
</html>
